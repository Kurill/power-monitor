<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>–ü—Ä–æ—à–∏–≤–∫–∞ ESP32 ‚Äî Power Monitor</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&family=Outfit:wght@300;400;500;600;700&display=swap" rel="stylesheet">

    <style>
        :root {
            --bg-void: #030305;
            --bg-surface: #0a0a0f;
            --bg-elevated: #111118;
            --bg-input: #08080c;
            --electric: #fbbf24;
            --electric-dim: #b8860b;
            --electric-glow: rgba(251, 191, 36, 0.25);
            --electric-subtle: rgba(251, 191, 36, 0.08);
            --success: #10b981;
            --success-glow: rgba(16, 185, 129, 0.25);
            --danger: #ef4444;
            --text-primary: #fafafa;
            --text-secondary: #a1a1aa;
            --text-tertiary: #52525b;
            --border: rgba(251, 191, 36, 0.12);
            --border-subtle: rgba(255,255,255,0.06);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        html {
            background: var(--bg-void);
        }

        body {
            font-family: 'Outfit', system-ui, sans-serif;
            background: var(--bg-void);
            color: var(--text-primary);
            min-height: 100vh;
            line-height: 1.5;
            overflow-x: hidden;
        }

        /* Circuit board pattern background */
        .circuit-bg {
            position: fixed;
            inset: 0;
            opacity: 0.4;
            pointer-events: none;
            background:
                linear-gradient(90deg, transparent 49.5%, var(--electric-subtle) 49.5%, var(--electric-subtle) 50.5%, transparent 50.5%),
                linear-gradient(0deg, transparent 49.5%, var(--electric-subtle) 49.5%, var(--electric-subtle) 50.5%, transparent 50.5%);
            background-size: 60px 60px;
            mask-image: radial-gradient(ellipse 80% 60% at 50% 0%, black 0%, transparent 70%);
        }

        /* Animated glow orb */
        .glow-orb {
            position: fixed;
            top: -200px;
            left: 50%;
            transform: translateX(-50%);
            width: 600px;
            height: 400px;
            background: radial-gradient(ellipse, var(--electric-glow) 0%, transparent 70%);
            pointer-events: none;
            animation: orb-pulse 4s ease-in-out infinite;
        }

        @keyframes orb-pulse {
            0%, 100% { opacity: 0.6; transform: translateX(-50%) scale(1); }
            50% { opacity: 0.9; transform: translateX(-50%) scale(1.1); }
        }

        /* Scanline effect */
        .scanlines {
            position: fixed;
            inset: 0;
            pointer-events: none;
            background: repeating-linear-gradient(
                0deg,
                transparent 0px,
                transparent 2px,
                rgba(0,0,0,0.1) 2px,
                rgba(0,0,0,0.1) 4px
            );
            z-index: 1000;
            opacity: 0.3;
        }

        .container {
            max-width: 480px;
            margin: 0 auto;
            padding: 48px 24px 80px;
            position: relative;
            z-index: 1;
        }

        /* Header */
        .header {
            text-align: center;
            margin-bottom: 48px;
        }

        .logo {
            display: inline-flex;
            align-items: center;
            gap: 14px;
            text-decoration: none;
            color: var(--text-primary);
            margin-bottom: 32px;
            transition: transform 0.2s;
        }

        .logo:hover {
            transform: scale(1.02);
        }

        .logo-icon {
            width: 52px;
            height: 52px;
            background: linear-gradient(135deg, var(--electric) 0%, var(--electric-dim) 100%);
            border-radius: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 28px;
            box-shadow:
                0 0 40px var(--electric-glow),
                inset 0 1px 0 rgba(255,255,255,0.2);
            position: relative;
        }

        .logo-icon::after {
            content: '';
            position: absolute;
            inset: -2px;
            border-radius: 16px;
            border: 1px solid var(--electric);
            opacity: 0.3;
        }

        .logo-text {
            font-family: 'Space Mono', monospace;
            font-weight: 700;
            font-size: 18px;
            letter-spacing: -0.5px;
        }

        .page-title {
            font-family: 'Space Mono', monospace;
            font-size: 32px;
            font-weight: 700;
            margin-bottom: 12px;
            letter-spacing: -1px;
            background: linear-gradient(135deg, var(--text-primary) 0%, var(--text-secondary) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .page-subtitle {
            color: var(--text-secondary);
            font-size: 15px;
            font-weight: 400;
        }

        /* Browser warning */
        .browser-warning {
            background: rgba(239, 68, 68, 0.08);
            border: 1px solid rgba(239, 68, 68, 0.3);
            border-radius: 12px;
            padding: 16px 20px;
            margin-bottom: 32px;
            text-align: center;
            font-size: 14px;
            display: none;
            backdrop-filter: blur(10px);
        }

        .browser-warning.visible {
            display: block;
            animation: shake 0.5s ease-in-out;
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }

        /* Steps */
        .step {
            background: var(--bg-surface);
            border: 1px solid var(--border-subtle);
            border-radius: 20px;
            padding: 28px;
            margin-bottom: 20px;
            position: relative;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .step::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, var(--electric), transparent);
            opacity: 0;
            transition: opacity 0.3s;
        }

        .step:hover::before,
        .step.active::before {
            opacity: 0.5;
        }

        .step.completed {
            border-color: rgba(16, 185, 129, 0.3);
        }

        .step.completed::before {
            background: linear-gradient(90deg, transparent, var(--success), transparent);
            opacity: 0.5;
        }

        .step-header {
            display: flex;
            align-items: center;
            gap: 16px;
            margin-bottom: 16px;
        }

        .step-number {
            width: 36px;
            height: 36px;
            border-radius: 10px;
            background: var(--bg-elevated);
            border: 2px solid var(--electric);
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Space Mono', monospace;
            font-weight: 700;
            font-size: 14px;
            color: var(--electric);
            flex-shrink: 0;
            transition: all 0.3s;
        }

        .step-number.done {
            background: var(--success);
            border-color: var(--success);
            color: white;
            box-shadow: 0 0 20px var(--success-glow);
        }

        .step-title {
            font-family: 'Space Mono', monospace;
            font-size: 15px;
            font-weight: 700;
            letter-spacing: -0.3px;
        }

        .step-desc {
            color: var(--text-secondary);
            font-size: 14px;
            margin-bottom: 20px;
            line-height: 1.6;
        }

        /* Input */
        .input-wrapper {
            position: relative;
        }

        .form-input {
            width: 100%;
            padding: 16px 20px;
            background: var(--bg-input);
            border: 2px solid var(--border-subtle);
            border-radius: 12px;
            color: var(--text-primary);
            font-size: 16px;
            font-family: 'Outfit', sans-serif;
            font-weight: 500;
            transition: all 0.2s;
        }

        .form-input:focus {
            outline: none;
            border-color: var(--electric);
            box-shadow: 0 0 0 4px var(--electric-subtle);
            background: var(--bg-surface);
        }

        .form-input::placeholder {
            color: var(--text-tertiary);
            font-weight: 400;
        }

        /* Buttons */
        .btn {
            width: 100%;
            padding: 18px 28px;
            border: none;
            border-radius: 14px;
            font-size: 15px;
            font-weight: 600;
            font-family: 'Outfit', sans-serif;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            position: relative;
            overflow: hidden;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--electric) 0%, var(--electric-dim) 100%);
            color: var(--bg-void);
            box-shadow: 0 4px 20px var(--electric-glow);
        }

        .btn-primary::before {
            content: '';
            position: absolute;
            inset: 0;
            background: linear-gradient(135deg, rgba(255,255,255,0.2) 0%, transparent 50%);
            opacity: 0;
            transition: opacity 0.2s;
        }

        .btn-primary:hover:not(:disabled)::before {
            opacity: 1;
        }

        .btn-primary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 8px 40px var(--electric-glow);
        }

        .btn-primary:active:not(:disabled) {
            transform: translateY(0);
        }

        .btn-primary:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            box-shadow: none;
        }

        .btn.flashing {
            animation: btn-pulse 1.5s ease-in-out infinite;
        }

        @keyframes btn-pulse {
            0%, 100% { box-shadow: 0 4px 20px var(--electric-glow); }
            50% { box-shadow: 0 4px 40px var(--electric-glow), 0 0 60px var(--electric-glow); }
        }

        .btn-icon {
            font-size: 18px;
        }

        /* Progress */
        .progress-container {
            margin-top: 24px;
            display: none;
        }

        .progress-container.visible {
            display: block;
            animation: fade-in 0.3s ease;
        }

        @keyframes fade-in {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .progress-bar {
            height: 6px;
            background: var(--bg-elevated);
            border-radius: 3px;
            overflow: hidden;
            margin-bottom: 12px;
            position: relative;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--electric), var(--success));
            width: 0%;
            transition: width 0.3s ease;
            border-radius: 3px;
            position: relative;
        }

        .progress-fill::after {
            content: '';
            position: absolute;
            top: 0;
            right: 0;
            bottom: 0;
            width: 100px;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3));
            animation: progress-shine 1.5s ease-in-out infinite;
        }

        @keyframes progress-shine {
            0% { transform: translateX(-100px); }
            100% { transform: translateX(400px); }
        }

        .progress-text {
            font-family: 'Space Mono', monospace;
            font-size: 12px;
            color: var(--text-secondary);
            text-align: center;
        }

        /* Log */
        .flash-log {
            margin-top: 20px;
            padding: 16px;
            background: var(--bg-void);
            border: 1px solid var(--border-subtle);
            border-radius: 10px;
            font-family: 'Space Mono', monospace;
            font-size: 11px;
            max-height: 180px;
            overflow-y: auto;
            display: none;
            line-height: 1.7;
        }

        .flash-log.visible {
            display: block;
            animation: fade-in 0.3s ease;
        }

        .flash-log::-webkit-scrollbar {
            width: 6px;
        }

        .flash-log::-webkit-scrollbar-track {
            background: var(--bg-surface);
            border-radius: 3px;
        }

        .flash-log::-webkit-scrollbar-thumb {
            background: var(--text-tertiary);
            border-radius: 3px;
        }

        .flash-log div {
            color: var(--text-secondary);
        }

        .flash-log .error { color: var(--danger); }
        .flash-log .success { color: var(--success); }

        /* WiFi Section */
        .wifi-section {
            margin-top: 4px;
        }

        .wifi-btn {
            width: 100%;
            padding: 18px 28px;
            border: none;
            border-radius: 14px;
            font-size: 15px;
            font-weight: 600;
            font-family: 'Outfit', sans-serif;
            cursor: pointer;
            background: linear-gradient(135deg, var(--success) 0%, #059669 100%);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            transition: all 0.2s;
            box-shadow: 0 4px 20px var(--success-glow);
        }

        .wifi-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 8px 40px var(--success-glow);
        }

        .wifi-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            box-shadow: none;
        }

        .wifi-btn.pulse-attention {
            animation: attention-pulse 1s ease-in-out infinite;
        }

        @keyframes attention-pulse {
            0%, 100% {
                box-shadow: 0 4px 20px var(--success-glow);
                transform: scale(1);
            }
            50% {
                box-shadow: 0 4px 40px var(--success-glow), 0 0 60px var(--success-glow);
                transform: scale(1.02);
            }
        }

        .wifi-status {
            margin-top: 16px;
            padding: 14px 18px;
            background: rgba(16, 185, 129, 0.1);
            border: 1px solid rgba(16, 185, 129, 0.3);
            border-radius: 10px;
            font-size: 14px;
            display: none;
            color: var(--success);
        }

        .wifi-status.visible {
            display: block;
        }

        .wifi-dialog {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .wifi-dialog-content {
            background: var(--bg-elevated);
            border: 1px solid var(--border);
            border-radius: 16px;
            padding: 24px;
            width: 90%;
            max-width: 360px;
        }

        .wifi-dialog h3 {
            margin: 0 0 20px 0;
            color: var(--electric);
            font-family: 'Space Mono', monospace;
        }

        .wifi-input {
            width: 100%;
            padding: 12px 16px;
            margin-bottom: 12px;
            border: 1px solid var(--border);
            border-radius: 8px;
            background: var(--bg-input);
            color: var(--text-primary);
            font-size: 15px;
            font-family: 'Outfit', sans-serif;
            box-sizing: border-box;
        }

        .wifi-input:focus {
            outline: none;
            border-color: var(--electric);
        }

        .wifi-scan-row {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
        }

        .wifi-select {
            flex: 1;
            margin-bottom: 0;
        }

        .wifi-scan-btn {
            padding: 12px 16px;
            border: 1px solid var(--border);
            border-radius: 8px;
            background: var(--bg-input);
            color: var(--text-primary);
            font-size: 16px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .wifi-scan-btn:hover {
            border-color: var(--electric);
            background: var(--electric-subtle);
        }

        .wifi-scan-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .wifi-submit {
            width: 100%;
            padding: 14px;
            border: none;
            border-radius: 8px;
            background: var(--success);
            color: white;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            margin-bottom: 12px;
        }

        .wifi-submit:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .wifi-log {
            background: var(--bg-void);
            border-radius: 8px;
            padding: 12px;
            font-family: 'Space Mono', monospace;
            font-size: 12px;
            max-height: 150px;
            overflow-y: auto;
            margin-bottom: 12px;
            display: none;
        }

        .wifi-log.visible {
            display: block;
        }

        .wifi-log .success { color: var(--success); }
        .wifi-log .error { color: var(--danger); }

        .wifi-close {
            width: 100%;
            padding: 12px;
            border: 1px solid var(--border);
            border-radius: 8px;
            background: transparent;
            color: var(--text-secondary);
            font-size: 14px;
            cursor: pointer;
            animation: fade-in 0.3s ease;
        }

        /* Footer */
        .footer {
            text-align: center;
            margin-top: 40px;
        }

        .footer-link {
            color: var(--text-tertiary);
            text-decoration: none;
            font-size: 14px;
            font-weight: 500;
            transition: color 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        .footer-link:hover {
            color: var(--electric);
        }

        /* Connection line between steps */
        .step-connector {
            width: 2px;
            height: 20px;
            background: var(--border-subtle);
            margin: 0 auto;
            position: relative;
        }

        .step-connector::before {
            content: '';
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 6px;
            height: 6px;
            background: var(--bg-surface);
            border: 2px solid var(--border-subtle);
            border-radius: 50%;
        }
    </style>
</head>
<body>
    <div class="circuit-bg"></div>
    <div class="glow-orb"></div>
    <div class="scanlines"></div>

    <div class="container">
        <div class="header">
            <a href="/" class="logo">
                <div class="logo-icon">‚ö°</div>
                <span class="logo-text">Power Monitor</span>
            </a>
            <h1 class="page-title">–ü—Ä–æ—à–∏–≤–∫–∞ ESP32</h1>
            <p class="page-subtitle">–í—Å—Ç–∞–Ω–æ–≤–∏ –ø—Ä–æ—à–∏–≤–∫—É —Ç–∞ –Ω–∞–ª–∞—à—Ç—É–π WiFi</p>
        </div>

        <div class="browser-warning" id="browserWarning">
            ‚ö†Ô∏è –¶–µ–π –±—Ä–∞—É–∑–µ—Ä –Ω–µ –ø—ñ–¥—Ç—Ä–∏–º—É—î Web Serial. –í–∏–∫–æ—Ä–∏—Å—Ç–∞–π <strong>Chrome</strong> –∞–±–æ <strong>Edge</strong> –Ω–∞ –∫–æ–º–ø'—é—Ç–µ—Ä—ñ.
        </div>

        <!-- Step 1: Device Name -->
        <div class="step" id="step1">
            <div class="step-header">
                <div class="step-number" id="step1num">1</div>
                <div class="step-title">–ù–∞–∑–≤–∞ –ø—Ä–∏—Å—Ç—Ä–æ—é</div>
            </div>
            <div class="step-desc">–í–≤–µ–¥–∏ –Ω–∞–∑–≤—É –¥–ª—è —ñ–¥–µ–Ω—Ç–∏—Ñ—ñ–∫–∞—Ü—ñ—ó ‚Äî –Ω–∞–ø—Ä–∏–∫–ª–∞–¥, ¬´–ö–≤–∞—Ä—Ç–∏—Ä–∞¬ª –∞–±–æ ¬´–î–∞—á–∞¬ª</div>
            <div class="input-wrapper">
                <input type="text" class="form-input" id="deviceName" placeholder="–í–≤–µ–¥–∏ –Ω–∞–∑–≤—É –ø—Ä–∏—Å—Ç—Ä–æ—é" maxlength="40" autocomplete="off" spellcheck="false">
            </div>
        </div>

        <div class="step-connector"></div>

        <!-- Step 2: Flash -->
        <div class="step" id="step2">
            <div class="step-header">
                <div class="step-number" id="step2num">2</div>
                <div class="step-title">–ü—Ä–æ—à–∏–≤–∫–∞</div>
            </div>
            <div class="step-desc">–ü—ñ–¥–∫–ª—é—á–∏ ESP32 –¥–æ USB —Ç–∞ –Ω–∞—Ç–∏—Å–Ω–∏ –∫–Ω–æ–ø–∫—É –ø—Ä–æ—à–∏–≤–∫–∏</div>

            <button class="btn btn-primary" id="flashBtn" disabled>
                <span class="btn-icon">‚ö°</span>
                <span id="flashBtnText">–ü—Ä–æ—à–∏—Ç–∏ ESP32</span>
            </button>

            <div class="progress-container" id="progressContainer">
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                <div class="progress-text" id="progressText">–ü—ñ–¥–≥–æ—Ç–æ–≤–∫–∞...</div>
            </div>

            <div class="flash-log" id="flashLog"></div>
        </div>

        <div class="step-connector"></div>

        <!-- Step 3: WiFi -->
        <div class="step" id="step3">
            <div class="step-header">
                <div class="step-number" id="step3num">3</div>
                <div class="step-title">–ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è WiFi</div>
            </div>
            <div class="step-desc">–ü—ñ—Å–ª—è –ø—Ä–æ—à–∏–≤–∫–∏ –Ω–∞–ª–∞—à—Ç—É–π WiFi –º–µ—Ä–µ–∂—É –¥–ª—è –ø—Ä–∏—Å—Ç—Ä–æ—é</div>

            <div class="wifi-section">
                <button class="wifi-btn" id="wifiBtnInner" disabled>
                    <span>üì∂</span>
                    <span>–ù–∞–ª–∞—à—Ç—É–≤–∞—Ç–∏ WiFi</span>
                </button>

                <div id="wifiDialog" class="wifi-dialog" style="display:none;">
                    <div class="wifi-dialog-content">
                        <h3>–ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è WiFi</h3>
                        <div id="wifiForm">
                            <div class="wifi-scan-row">
                                <select id="wifiSelect" class="wifi-input wifi-select">
                                    <option value="">-- –û–±–µ—Ä—ñ—Ç—å –º–µ—Ä–µ–∂—É --</option>
                                </select>
                                <button id="wifiScan" class="wifi-scan-btn" title="–°–∫–∞–Ω—É–≤–∞—Ç–∏">üîç</button>
                            </div>
                            <input type="text" id="wifiSsid" placeholder="–ê–±–æ –≤–≤–µ–¥—ñ—Ç—å SSID –≤—Ä—É—á–Ω—É" class="wifi-input">
                            <input type="password" id="wifiPass" placeholder="–ü–∞—Ä–æ–ª—å" class="wifi-input">
                            <button id="wifiConnect" class="wifi-submit">–ü—ñ–¥–∫–ª—é—á–∏—Ç–∏</button>
                        </div>
                        <div id="wifiLog" class="wifi-log"></div>
                        <button id="wifiClose" class="wifi-close">–ó–∞–∫—Ä–∏—Ç–∏</button>
                    </div>
                </div>

                <div class="wifi-status" id="wifiStatus"></div>
            </div>
        </div>

        <div class="footer">
            <a href="/" class="footer-link">
                <span>‚Üê</span>
                <span>–ù–∞ –≥–æ–ª–æ–≤–Ω—É</span>
            </a>
        </div>
    </div>

    <script type="module">
        // Use local esptool-js bundle with flushInput fix
        import { ESPLoader, Transport } from '/esptool-bundle.js';

        const SERVER = 'https://power-monitor.club';
        let currentDeviceId = '';
        let cachedOwnerEmail = null;
        let flashSuccess = false;

        // State for flashing
        let device = null;
        let transport = null;
        let esploader = null;

        // Elements
        const deviceNameInput = document.getElementById('deviceName');
        const flashBtn = document.getElementById('flashBtn');
        const flashBtnText = document.getElementById('flashBtnText');
        const progressContainer = document.getElementById('progressContainer');
        const progressFill = document.getElementById('progressFill');
        const progressText = document.getElementById('progressText');
        const flashLog = document.getElementById('flashLog');
        const wifiBtnInner = document.getElementById('wifiBtnInner');
        const wifiStatus = document.getElementById('wifiStatus');
        const browserWarning = document.getElementById('browserWarning');

        // Check browser support
        if (!navigator.serial) {
            browserWarning.classList.add('visible');
        }

        // Get owner email (cached)
        fetch('/api/me', { credentials: 'include' }).then(r => r.ok ? r.json() : null).then(data => {
            cachedOwnerEmail = data?.email || null;
            console.log('Logged in as:', cachedOwnerEmail || 'not logged in');
        }).catch(e => console.error('Auth check failed:', e));

        // Generate device ID from name
        function generateId(name) {
            const slug = name.toLowerCase()
                .replace(/[–∞-—è—ñ—ó—î“ë]/g, c => {
                    const map = {'–∞':'a','–±':'b','–≤':'v','–≥':'h','“ë':'g','–¥':'d','–µ':'e','—î':'ye','–∂':'zh','–∑':'z','–∏':'y','—ñ':'i','—ó':'yi','–π':'y','–∫':'k','–ª':'l','–º':'m','–Ω':'n','–æ':'o','–ø':'p','—Ä':'r','—Å':'s','—Ç':'t','—É':'u','—Ñ':'f','—Ö':'kh','—Ü':'ts','—á':'ch','—à':'sh','—â':'shch','—å':'','—é':'yu','—è':'ya'};
                    return map[c] || c;
                })
                .replace(/[^a-z0-9]+/g, '_')
                .replace(/^_|_$/g, '')
                .substring(0, 20);
            return slug + '_' + Math.random().toString(36).substring(2, 6);
        }

        // Logging
        function log(msg, type = '') {
            flashLog.classList.add('visible');
            const line = document.createElement('div');
            if (type) line.className = type;
            line.textContent = msg;
            flashLog.appendChild(line);
            flashLog.scrollTop = flashLog.scrollHeight;
        }

        function setProgress(pct, text) {
            progressContainer.classList.add('visible');
            progressFill.style.width = pct + '%';
            progressText.textContent = text;
        }

        // Terminal for esptool
        const espLoaderTerminal = {
            clean() { flashLog.innerHTML = ''; },
            writeLine(data) { log(data); },
            write(data) { log(data); }
        };

        // Cleanup
        function cleanUp() {
            device = null;
            transport = null;
            esploader = null;
        }

        // UI update
        function updateUI() {
            const name = deviceNameInput.value.trim();
            if (name.length >= 3) {
                flashBtn.disabled = false;
                currentDeviceId = generateId(name);
                document.getElementById('step1').classList.add('active');
            } else {
                flashBtn.disabled = true;
                currentDeviceId = '';
                document.getElementById('step1').classList.remove('active');
            }

            // Enable WiFi button only after successful flash
            wifiBtnInner.disabled = !flashSuccess;
        }

        // Bind input event
        deviceNameInput.addEventListener('input', updateUI);

        // Flash button click - direct flashing
        flashBtn.onclick = async () => {
            const name = deviceNameInput.value.trim();
            if (name.length < 3) return;

            if (!navigator.serial) {
                alert("–ë—Ä–∞—É–∑–µ—Ä –Ω–µ –ø—ñ–¥—Ç—Ä–∏–º—É—î Web Serial. –í–∏–∫–æ—Ä–∏—Å—Ç–∞–π Chrome –∞–±–æ Edge.");
                return;
            }

            flashBtn.disabled = true;
            flashBtnText.textContent = "–ü—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è...";
            flashBtn.classList.add('flashing');
            document.getElementById('step2').classList.add('active');

            try {
                // 1. Request port
                log("–í–∏–±–µ—Ä–∏ COM –ø–æ—Ä—Ç...");
                device = await navigator.serial.requestPort({});
                const deviceInfo = device.getInfo();
                log("Port: VID=0x" + deviceInfo.usbVendorId?.toString(16) + " PID=0x" + deviceInfo.usbProductId?.toString(16));

                // 2. Create transport
                log("–°—Ç–≤–æ—Ä–µ–Ω–Ω—è transport...");
                transport = new Transport(device, true);

                // 3. Create loader
                log("–°—Ç–≤–æ—Ä–µ–Ω–Ω—è ESPLoader...");
                esploader = new ESPLoader({
                    transport,
                    baudrate: 460800,
                    terminal: espLoaderTerminal,
                    debugLogging: false
                });

                // 4. Connect to chip
                setProgress(5, "–ü—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è –¥–æ ESP32...");
                log("–ü—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è –¥–æ —á—ñ–ø–∞...");
                const chip = await esploader.main();
                log("–ü—ñ–¥–∫–ª—é—á–µ–Ω–æ: " + chip, "success");

                // 5. Download firmware
                setProgress(15, "–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –ø—Ä–æ—à–∏–≤–∫–∏...");
                flashBtnText.textContent = "–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è...";
                log("–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –ø—Ä–æ—à–∏–≤–∫–∏...");

                const fwUrl = `${SERVER}/api/firmware?device=${currentDeviceId}&name=${encodeURIComponent(name)}&server=178.62.112.232&improv=true`;
                const resp = await fetch(fwUrl);
                if (!resp.ok) throw new Error("–ü–æ–º–∏–ª–∫–∞ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è: " + resp.status);

                const fwData = new Uint8Array(await resp.arrayBuffer());
                log("–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–æ " + fwData.length + " –±–∞–π—Ç", "success");

                // Convert to binary string using latin1 (ISO-8859-1) - 1:1 byte mapping
                const binaryString = new TextDecoder('iso-8859-1').decode(fwData);

                // 6. Flash firmware
                setProgress(20, "–ü—Ä–æ—à–∏–≤–∫–∞...");
                flashBtnText.textContent = "–ü—Ä–æ—à–∏–≤–∫–∞...";
                log("–ü—Ä–æ—à–∏–≤–∫–∞...");
                const startTime = Date.now();

                await esploader.writeFlash({
                    fileArray: [{ data: binaryString, address: 0 }],
                    flashSize: 'keep',
                    flashMode: 'keep',
                    flashFreq: 'keep',
                    eraseAll: false,
                    compress: true,
                    reportProgress: (fileIndex, written, total) => {
                        const pct = Math.round(20 + (written / total * 75));
                        setProgress(pct, `–ü—Ä–æ—à–∏–≤–∫–∞: ${Math.round(written / total * 100)}%`);
                    }
                });

                const totalTime = ((Date.now() - startTime) / 1000).toFixed(1);
                log("–ü—Ä–æ—à–∏–≤–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞ –∑–∞ " + totalTime + " —Å–µ–∫!", "success");

                // 7. Hard reset
                setProgress(98, "–ü–µ—Ä–µ–∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è...");
                log("Hard reset...");
                await transport.setDTR(false);
                await transport.setRTS(true);
                await new Promise(r => setTimeout(r, 100));
                await transport.setRTS(false);

                // 8. Disconnect and release port completely
                await transport.disconnect();
                try { await device.close(); } catch(e) {}
                try { await device.forget(); } catch(e) {} // Reset browser's port state
                cleanUp();

                // Success - but wait for ESP32 to boot before enabling WiFi
                setProgress(100, "–ì–æ—Ç–æ–≤–æ! –û—á—ñ–∫—É—î–º–æ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è...");
                log("–ü—Ä–æ—à–∏–≤–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞. –û—á—ñ–∫—É—î–º–æ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è ESP32...", "success");

                // Wait for ESP32 to boot (3s delay in firmware + boot time)
                await new Promise(r => setTimeout(r, 5000));

                log("–ì–æ—Ç–æ–≤–æ! –ù–∞—Ç–∏—Å–Ω–∏ –∫–Ω–æ–ø–∫—É –Ω–∏–∂—á–µ –¥–ª—è –Ω–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è WiFi.", "success");
                flashSuccess = true;
                wifiBtnInner.disabled = false;

                // Highlight WiFi button and scroll to it
                document.getElementById('step3').classList.add('active');
                wifiBtnInner.classList.add('pulse-attention');
                wifiBtnInner.scrollIntoView({ behavior: 'smooth', block: 'center' });
                document.getElementById('step2num').textContent = '‚úì';
                document.getElementById('step2num').classList.add('done');
                document.getElementById('step2').classList.remove('active');
                document.getElementById('step2').classList.add('completed');
                document.getElementById('step3').classList.add('active');
                flashBtnText.textContent = "–ü—Ä–æ—à–∏—Ç–æ ‚úì";
                flashBtn.classList.remove('flashing');

            } catch (e) {
                log("–ü–æ–º–∏–ª–∫–∞: " + e.message, "error");
                console.error(e);

                // Cleanup on error
                if (transport) {
                    try { await transport.disconnect(); } catch(err) { console.error(err); }
                }
                if (device) {
                    try { await device.close(); } catch(err) { console.error(err); }
                    try { await device.forget(); } catch(err) {}
                }
                cleanUp();

                flashBtn.disabled = false;
                flashBtnText.textContent = "–ü—Ä–æ—à–∏—Ç–∏ ESP32";
                flashBtn.classList.remove('flashing');
                document.getElementById('step2').classList.remove('active');
                setProgress(0, "–ü–æ–º–∏–ª–∫–∞");
            }
        };

        // Custom Improv WiFi implementation
        const wifiDialog = document.getElementById('wifiDialog');
        const wifiSelect = document.getElementById('wifiSelect');
        const wifiSsid = document.getElementById('wifiSsid');
        const wifiPass = document.getElementById('wifiPass');
        const wifiConnectBtn = document.getElementById('wifiConnect');
        const wifiCloseBtn = document.getElementById('wifiClose');
        const wifiScanBtn = document.getElementById('wifiScan');
        const wifiLogEl = document.getElementById('wifiLog');

        let improvPort = null;
        let improvReader = null;
        let improvWriter = null;

        function wifiLog(msg, type = '') {
            wifiLogEl.classList.add('visible');
            const line = document.createElement('div');
            if (type) line.className = type;
            line.textContent = msg;
            wifiLogEl.appendChild(line);
            wifiLogEl.scrollTop = wifiLogEl.scrollHeight;
        }

        // Improv protocol helpers
        function buildImprovPacket(type, data) {
            const header = [0x49, 0x4D, 0x50, 0x52, 0x4F, 0x56]; // "IMPROV"
            const version = 0x01;
            const packet = [...header, version, type, data.length, ...data];
            const checksum = packet.reduce((a, b) => a + b, 0) & 0xFF;
            return new Uint8Array([...packet, checksum, 0x0A]);
        }

        async function improvSend(type, data = []) {
            const packet = buildImprovPacket(type, data);
            await improvWriter.write(packet);
        }

        async function improvReadPacket(timeout = 5000) {
            const startTime = Date.now();
            let buffer = [];

            while (Date.now() - startTime < timeout) {
                try {
                    const { value, done } = await Promise.race([
                        improvReader.read(),
                        new Promise((_, reject) => setTimeout(() => reject(new Error('timeout')), 100))
                    ]);

                    if (done) break;
                    if (value) {
                        buffer.push(...value);

                        // Look for IMPROV header
                        while (buffer.length >= 10) {
                            const headerIdx = buffer.findIndex((v, i) =>
                                i <= buffer.length - 6 &&
                                buffer[i] === 0x49 && buffer[i+1] === 0x4D &&
                                buffer[i+2] === 0x50 && buffer[i+3] === 0x52 &&
                                buffer[i+4] === 0x4F && buffer[i+5] === 0x56
                            );

                            if (headerIdx === -1) {
                                buffer = buffer.slice(-5);
                                break;
                            }

                            if (headerIdx > 0) buffer = buffer.slice(headerIdx);

                            if (buffer.length < 10) break;

                            const dataLen = buffer[8];
                            const packetLen = 9 + dataLen + 1; // header + type + len + data + checksum

                            if (buffer.length < packetLen) break;

                            const packet = buffer.slice(0, packetLen);
                            buffer = buffer.slice(packetLen);

                            return {
                                type: packet[7],
                                data: packet.slice(9, 9 + dataLen)
                            };
                        }
                    }
                } catch (e) {
                    if (e.message !== 'timeout') throw e;
                }
            }
            return null;
        }

        async function improvConnect() {
            try {
                improvPort = await navigator.serial.requestPort();
                await improvPort.open({ baudRate: 115200 });

                improvReader = improvPort.readable.getReader();
                improvWriter = improvPort.writable.getWriter();

                wifiLog('–ü—ñ–¥–∫–ª—é—á–µ–Ω–æ –¥–æ –ø–æ—Ä—Ç—É');

                // Send request current state
                await improvSend(0x03); // REQUEST_CURRENT_STATE
                wifiLog('–ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ Improv...');

                const response = await improvReadPacket(3000);
                if (!response) {
                    throw new Error('ESP32 –Ω–µ –≤—ñ–¥–ø–æ–≤—ñ–¥–∞—î –Ω–∞ Improv');
                }

                wifiLog('Improv –∑–Ω–∞–π–¥–µ–Ω–æ!', 'success');
                return true;

            } catch (e) {
                wifiLog('–ü–æ–º–∏–ª–∫–∞: ' + e.message, 'error');
                return false;
            }
        }

        async function improvSendWifi(ssid, password) {
            try {
                wifiLog(`–ü—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è –¥–æ "${ssid}"...`);

                // Build WiFi credentials packet (RPC command format)
                const ssidBytes = new TextEncoder().encode(ssid);
                const passBytes = new TextEncoder().encode(password);
                const totalLen = 1 + ssidBytes.length + 1 + passBytes.length;
                const data = [0x01, totalLen, ssidBytes.length, ...ssidBytes, passBytes.length, ...passBytes];

                await improvSend(0x03, data); // RPC command

                // Wait for response - ESP32 sends multiple packets
                let gotProvisioning = false;
                const startTime = Date.now();

                while (Date.now() - startTime < 20000) {
                    const response = await improvReadPacket(2000);
                    if (!response) {
                        // If we got PROVISIONING state and no more responses, assume success
                        if (gotProvisioning) {
                            wifiLog('WiFi –Ω–∞–ª–∞—à—Ç–æ–≤–∞–Ω–æ!', 'success');
                            return true;
                        }
                        continue;
                    }

                    console.log('Improv response:', response.type, response.data);

                    if (response.type === 0x01) { // CURRENT_STATE
                        const state = response.data[0];
                        if (state === 0x03) { // PROVISIONING
                            wifiLog('–ü—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è...');
                            gotProvisioning = true;
                        } else if (state === 0x04) { // PROVISIONED
                            wifiLog('WiFi –Ω–∞–ª–∞—à—Ç–æ–≤–∞–Ω–æ!', 'success');
                            return true;
                        }
                    } else if (response.type === 0x04) { // RPC_RESULT - success
                        wifiLog('WiFi –Ω–∞–ª–∞—à—Ç–æ–≤–∞–Ω–æ!', 'success');
                        return true;
                    } else if (response.type === 0x05) { // ERROR_STATE
                        const errCode = response.data[0];
                        const errors = ['', 'Invalid RPC', 'Unknown RPC', 'Unable to connect', 'Not authorized'];
                        throw new Error(errors[errCode] || `Error ${errCode}`);
                    }
                }

                // If we got provisioning state, consider it success
                if (gotProvisioning) {
                    wifiLog('WiFi –Ω–∞–ª–∞—à—Ç–æ–≤–∞–Ω–æ!', 'success');
                    return true;
                }

                throw new Error('–¢–∞–π–º–∞—É—Ç –ø—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è');

            } catch (e) {
                wifiLog('–ü–æ–º–∏–ª–∫–∞: ' + e.message, 'error');
                return false;
            }
        }

        async function improvDisconnect() {
            try {
                if (improvReader) { improvReader.releaseLock(); improvReader = null; }
                if (improvWriter) { improvWriter.releaseLock(); improvWriter = null; }
                if (improvPort) { await improvPort.close(); improvPort = null; }
            } catch (e) {}
        }

        // WiFi button click
        wifiBtnInner.onclick = async () => {
            wifiLogEl.innerHTML = '';
            wifiLogEl.classList.remove('visible');
            wifiSelect.innerHTML = '<option value="">-- –û–±–µ—Ä—ñ—Ç—å –º–µ—Ä–µ–∂—É --</option>';
            wifiSsid.value = '';
            wifiPass.value = '';
            wifiDialog.style.display = 'flex';

            if (await improvConnect()) {
                // Auto-scan networks
                await improvScanNetworks();
                wifiPass.focus();
            }
        };

        // Connect button click
        wifiConnectBtn.onclick = async () => {
            const ssid = wifiSsid.value.trim();
            const pass = wifiPass.value;

            if (!ssid) {
                wifiLog('–í–≤–µ–¥—ñ—Ç—å –Ω–∞–∑–≤—É –º–µ—Ä–µ–∂—ñ', 'error');
                return;
            }

            wifiConnectBtn.disabled = true;

            if (await improvSendWifi(ssid, pass)) {
                wifiLog('WiFi –Ω–∞–ª–∞—à—Ç–æ–≤–∞–Ω–æ! –ß–µ–∫–∞—î–º–æ –ø–µ—Ä—à–∏–π –ø—ñ–Ω–≥...', 'success');

                // Wait for device to ping server (up to 60 seconds)
                let deviceOnline = false;
                const pingStart = Date.now();
                while (Date.now() - pingStart < 60000) {
                    try {
                        const resp = await fetch(`${SERVER}/api/status`);
                        const data = await resp.json();
                        if (data[currentDeviceId] && data[currentDeviceId].last_ping) {
                            const lastPing = new Date(data[currentDeviceId].last_ping);
                            // Check if ping is recent (within last 2 minutes)
                            if (Date.now() - lastPing.getTime() < 120000) {
                                deviceOnline = true;
                                wifiLog('–ü—Ä–∏—Å—Ç—Ä—ñ–π –æ–Ω–ª–∞–π–Ω!', 'success');
                                break;
                            }
                        }
                    } catch (e) {
                        console.error('Status check error:', e);
                    }
                    await new Promise(r => setTimeout(r, 3000));
                }

                if (!deviceOnline) {
                    wifiLog('–ü—Ä–∏—Å—Ç—Ä—ñ–π –Ω–µ –≤—ñ–¥–ø–æ–≤—ñ–¥–∞—î —Å–µ—Ä–≤–µ—Ä—É. –ü–µ—Ä–µ–≤—ñ—Ä—Ç–µ –ø—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è.', 'error');
                }

                // Update UI
                wifiStatus.textContent = deviceOnline
                    ? "WiFi –Ω–∞–ª–∞—à—Ç–æ–≤–∞–Ω–æ! –ü—Ä–∏—Å—Ç—Ä—ñ–π –æ–Ω–ª–∞–π–Ω."
                    : "WiFi –Ω–∞–ª–∞—à—Ç–æ–≤–∞–Ω–æ, –∞–ª–µ –ø—Ä–∏—Å—Ç—Ä—ñ–π –Ω–µ –≤—ñ–¥–ø–æ–≤—ñ–¥–∞—î —Å–µ—Ä–≤–µ—Ä—É.";
                wifiStatus.classList.add('visible');
                document.getElementById('step3num').textContent = '‚úì';
                document.getElementById('step3num').classList.add('done');
                document.getElementById('step3').classList.remove('active');
                document.getElementById('step3').classList.add('completed');

                // Auto-claim device
                if (cachedOwnerEmail) {
                    wifiLog(`–ü—Ä–∏–≤'—è–∑–∫–∞ –¥–æ ${cachedOwnerEmail}...`);
                    try {
                        const claimResp = await fetch(`${SERVER}/api/claim`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            credentials: 'include',
                            body: JSON.stringify({ device_id: currentDeviceId })
                        });
                        if (claimResp.ok) {
                            wifiLog('–ü—Ä–∏—Å—Ç—Ä—ñ–π –ø—Ä–∏–≤\'—è–∑–∞–Ω–æ!', 'success');
                        } else {
                            wifiLog(`–ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏–≤'—è–∑–∫–∏: ${claimResp.status}`, 'error');
                        }
                    } catch (e) {
                        wifiLog(`–ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏–≤'—è–∑–∫–∏: ${e.message}`, 'error');
                    }
                } else {
                    wifiLog('–£–≤—ñ–π–¥—ñ—Ç—å —â–æ–± –ø—Ä–∏–≤\'—è–∑–∞—Ç–∏ –ø—Ä–∏—Å—Ç—Ä—ñ–π –¥–æ –∞–∫–∞—É–Ω—Ç—É');
                }

                setTimeout(() => {
                    wifiDialog.style.display = 'none';
                    improvDisconnect();
                }, 3000);
            }

            wifiConnectBtn.disabled = false;
        };

        // Close button
        wifiCloseBtn.onclick = async () => {
            wifiDialog.style.display = 'none';
            await improvDisconnect();
        };

        // WiFi scan - RPC command 0x04
        async function improvScanNetworks() {
            wifiLog('–°–∫–∞–Ω—É–≤–∞–Ω–Ω—è –º–µ—Ä–µ–∂...');
            wifiScanBtn.disabled = true;
            wifiSelect.innerHTML = '<option value="">–°–∫–∞–Ω—É–≤–∞–Ω–Ω—è...</option>';

            try {
                // Send SCAN_WIFI command (RPC command 0x04)
                await improvSend(0x03, [0x04]); // RPC with command_id = 0x04

                // Wait for scan results - may come as multiple packets
                const networks = [];
                const startTime = Date.now();
                let gotResults = false;

                while (Date.now() - startTime < 15000) {
                    const response = await improvReadPacket(gotResults ? 500 : 5000);
                    if (!response) {
                        if (gotResults) break; // No more packets after we got some
                        continue;
                    }

                    console.log('Scan response:', response.type, response.data);

                    if (response.type === 0x04) { // RPC_RESULT
                        gotResults = true;
                        // Parse network data - each result contains 3 strings: SSID, RSSI, auth_required
                        let offset = 1; // Skip command ID
                        const data = response.data;

                        while (offset < data.length) {
                            // Read SSID
                            if (offset >= data.length) break;
                            const ssidLen = data[offset++];
                            if (offset + ssidLen > data.length) break;
                            const ssid = new TextDecoder().decode(new Uint8Array(data.slice(offset, offset + ssidLen)));
                            offset += ssidLen;

                            // Read RSSI
                            if (offset >= data.length) break;
                            const rssiLen = data[offset++];
                            if (offset + rssiLen > data.length) break;
                            const rssi = new TextDecoder().decode(new Uint8Array(data.slice(offset, offset + rssiLen)));
                            offset += rssiLen;

                            // Read auth required
                            if (offset >= data.length) break;
                            const authLen = data[offset++];
                            if (offset + authLen > data.length) break;
                            const auth = new TextDecoder().decode(new Uint8Array(data.slice(offset, offset + authLen)));
                            offset += authLen;

                            if (ssid) {
                                networks.push({ ssid, rssi: parseInt(rssi) || 0, auth: auth === 'YES' });
                            }
                        }
                    } else if (response.type === 0x05) { // ERROR_STATE
                        const errCode = response.data[0];
                        throw new Error(`Scan error: ${errCode}`);
                    }
                }

                // Remove duplicates (by SSID), keep strongest signal
                const uniqueNetworks = [];
                const seen = new Set();
                networks.sort((a, b) => b.rssi - a.rssi);
                for (const net of networks) {
                    if (!seen.has(net.ssid)) {
                        seen.add(net.ssid);
                        uniqueNetworks.push(net);
                    }
                }

                // Populate dropdown
                wifiSelect.innerHTML = '<option value="">-- –û–±–µ—Ä—ñ—Ç—å –º–µ—Ä–µ–∂—É --</option>';
                uniqueNetworks.forEach(net => {
                    const signal = net.rssi > -50 ? '‚ñì‚ñì‚ñì' : net.rssi > -70 ? '‚ñì‚ñì‚ñë' : '‚ñì‚ñë‚ñë';
                    const lock = net.auth ? 'üîí' : '';
                    const option = document.createElement('option');
                    option.value = net.ssid;
                    option.textContent = `${net.ssid} ${signal} ${lock}`;
                    wifiSelect.appendChild(option);
                });

                if (uniqueNetworks.length > 0) {
                    wifiLog(`–ó–Ω–∞–π–¥–µ–Ω–æ ${uniqueNetworks.length} –º–µ—Ä–µ–∂`, 'success');
                } else {
                    wifiLog('–ú–µ—Ä–µ–∂—ñ –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ. –í–≤–µ–¥—ñ—Ç—å SSID –≤—Ä—É—á–Ω—É.');
                }

            } catch (e) {
                wifiLog('–°–∫–∞–Ω—É–≤–∞–Ω–Ω—è –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–µ. –í–≤–µ–¥—ñ—Ç—å SSID –≤—Ä—É—á–Ω—É.', 'error');
                console.error('Scan error:', e);
                wifiSelect.innerHTML = '<option value="">-- –í–≤–µ–¥—ñ—Ç—å –≤—Ä—É—á–Ω—É --</option>';
            }

            wifiScanBtn.disabled = false;
        }

        // Scan button click
        wifiScanBtn.onclick = async () => {
            if (!improvPort) {
                wifiLog('–°–ø–æ—á–∞—Ç–∫—É –ø—ñ–¥–∫–ª—é—á—ñ—Ç—å—Å—è –¥–æ –ø–æ—Ä—Ç—É', 'error');
                return;
            }
            await improvScanNetworks();
        };

        // Select network from dropdown
        wifiSelect.onchange = () => {
            const selected = wifiSelect.value;
            if (selected) {
                wifiSsid.value = selected;
                wifiPass.focus();
            }
        };

        // Cleanup on page unload
        window.addEventListener('beforeunload', async () => {
            if (transport) {
                try { await transport.disconnect(); } catch(e) {}
            }
            await improvDisconnect();
        });
    </script>
</body>
</html>
